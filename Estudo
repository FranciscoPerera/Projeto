üöÄ T√≥picos Fundamentais da Ger√™ncia de Sistemas Operacionais
Este resumo abrange tr√™s √°reas cruciais do funcionamento de um sistema operacional: a ger√™ncia do processador (escalonamento), a ger√™ncia de mem√≥ria e a ger√™ncia de dispositivos de Entrada/Sa√≠da.
üî• GER√äNCIA DO PROCESSADOR - ESCALONAMENTO
O escalonamento de processos √© o cora√ß√£o da multiprograma√ß√£o. √â o mecanismo usado pelo sistema operacional (SO) para decidir qual processo, atualmente no estado de "pronto", deve ser o pr√≥ximo a usar a Unidade Central de Processamento (CPU). O objetivo √© otimizar m√©tricas como o throughput (vaz√£o), o tempo de resposta e a utiliza√ß√£o da CPU.
Arquitetura e Componentes Chave
O processo envolve dois m√≥dulos principais:
Scheduler (Escalonador): O algoritmo que decide, com base em crit√©rios e pol√≠ticas, qual processo ser√° o pr√≥ximo.
Dispatcher (Despachante): O m√≥dulo que executa a troca de contexto propriamente dita. Ele salva o estado do processo atual e carrega o estado do pr√≥ximo, atualizando registradores e o contador de programa (PC).
Lat√™ncia de Despacho: O tempo de overhead (gasto) inevit√°vel durante cada troca de contexto.
M√©tricas de Desempenho
A efici√™ncia do escalonamento √© medida por v√°rios par√¢metros:
Throughput (Vaz√£o): Quantidade total de processos conclu√≠dos por unidade de tempo (deseja-se maximizar).
Tempo de Turnaround (Retorno): Tempo total desde a submiss√£o at√© a conclus√£o do processo (deseja-se minimizar).
Tempo de Espera: Tempo que um processo passa na fila de prontos, aguardando a CPU (deseja-se minimizar).
Tempo de Resposta: Tempo desde a requisi√ß√£o inicial at√© a primeira resposta (cr√≠tico para sistemas interativos; deseja-se minimizar).
Utiliza√ß√£o da CPU: Percentual de tempo que a CPU est√° ocupada com tarefas √∫teis (deseja-se maximizar).
Algoritmos de Escalonamento Principais
Os algoritmos podem ser preemptivos (o SO pode interromper um processo em execu√ß√£o) ou n√£o preemptivos (o processo s√≥ libera a CPU voluntariamente).
FIFO (First-In, First-Out):
N√£o preemptivo. Processos s√£o executados estritamente na ordem de chegada.
Problema Principal: O "Efeito Convoy", onde um √∫nico processo longo atrasa desproporcionalmente todos os processos curtos que chegam depois dele.
SJF (Shortest Job First):
Pode ser n√£o preemptivo ou preemptivo (neste caso, chamado SRTF - Shortest Remaining Time First).
Vantagem: Produz o menor tempo m√©dio de espera entre todos os algoritmos.
Desvantagem: Requer um conhecimento pr√©vio (ou estimativa) precisa do tempo de execu√ß√£o do processo e pode causar starvation (inani√ß√£o) se processos curtos continuarem chegando.
Round Robin (RR):
Preemptivo por quantum de tempo. Cada processo recebe uma fatia de tempo fixa na CPU. Se n√£o terminar, √© movido para o final da fila de prontos.
Trade-off: Um quantum grande aproxima o RR do FIFO. Um quantum muito pequeno aumenta excessivamente o overhead devido ao grande n√∫mero de trocas de contexto.
Escalonamento por Prioridades:
Cada processo recebe um n√≠vel de prioridade (est√°tico ou din√¢mico). Processos de maior prioridade executam antes.
Problema: Starvation para processos de baixa prioridade.
Solu√ß√£o: Aging (Envelhecimento), que aumenta gradualmente a prioridade de um processo √† medida que ele espera na fila.
M√∫ltiplas Filas (Multilevel Queue):
Combina pol√≠ticas. O sistema usa v√°rias filas distintas, cada uma com sua pr√≥pria pol√≠tica (ex: RR para processos interativos de alta prioridade, FIFO para processos em batch de baixa prioridade).
Com realimenta√ß√£o (feedback), os processos podem migrar entre filas se mudarem de comportamento (ex: um processo que usa muita CPU migra para uma fila de prioridade mais baixa).
üî• GER√äNCIA DE MEM√ìRIA
A ger√™ncia de mem√≥ria lida com a aloca√ß√£o e o controle do espa√ßo de mem√≥ria principal (RAM) entre o sistema operacional e os m√∫ltiplos processos.
Problemas de Fragmenta√ß√£o
A aloca√ß√£o de mem√≥ria enfrenta dois tipos principais de desperd√≠cio de espa√ßo:
Fragmenta√ß√£o Interna: Ocorre quando a mem√≥ria alocada √© ligeiramente maior do que a solicitada (comum em parti√ß√µes fixas ou pagina√ß√£o).
Fragmenta√ß√£o Externa: Ocorre quando h√° mem√≥ria livre total suficiente para um novo processo, mas ela est√° espalhada em blocos n√£o cont√≠guos (comum em parti√ß√µes din√¢micas e segmenta√ß√£o). Solu√ß√µes incluem compacta√ß√£o de mem√≥ria ou uso de pagina√ß√£o/segmenta√ß√£o.
Estrat√©gias de Aloca√ß√£o (Parti√ß√µes Din√¢micas)
First Fit: Aloca na primeira parti√ß√£o livre encontrada que seja grande o suficiente. √â r√°pido, mas pode deixar pequenos fragmentos no in√≠cio da mem√≥ria.
Best Fit: Aloca na menor parti√ß√£o livre que satisfa√ßa o pedido. Minimiza o desperd√≠cio imediato, mas cria muitos fragmentos min√∫sculos e in√∫teis.
Worst Fit: Aloca na maior parti√ß√£o livre dispon√≠vel. Tenta deixar blocos livres grandes para aloca√ß√µes futuras, mas pode desperdi√ßar grandes quantidades de mem√≥ria.
Swapping (Troca)
O swapping √© um mecanismo que move processos inteiros (ou partes deles) entre a mem√≥ria principal (RAM) e uma √°rea de swap no disco r√≠gido para liberar RAM para outros processos. O grande problema √© a alta lat√™ncia do disco, que pode degradar severamente o desempenho se usado excessivamente.
üî• MEM√ìRIA VIRTUAL
A mem√≥ria virtual cria a ilus√£o de que cada processo tem acesso a um espa√ßo de mem√≥ria vasto e cont√≠guo, independentemente da quantidade de RAM f√≠sica dispon√≠vel.
Conceitos Chave
Espa√ßo de Endere√ßamento Virtual: O conjunto de endere√ßos que o programa v√™ e usa.
Espa√ßo de Endere√ßamento F√≠sico: Os endere√ßos reais na RAM.
MMU (Memory Management Unit): Hardware essencial que traduz endere√ßos virtuais em f√≠sicos em tempo real.
Pagina√ß√£o e Page Faults
A pagina√ß√£o divide a mem√≥ria virtual em blocos de tamanho fixo chamados p√°ginas, e a mem√≥ria f√≠sica em frames de mesmo tamanho. A tabela de p√°ginas, mantida pelo SO e gerenciada pela MMU, armazena o mapeamento entre eles.
Quando um programa tenta acessar uma p√°gina que n√£o est√° na RAM (o bit de validade na tabela √© 0), ocorre um Page Fault (falha de p√°gina). O SO interv√©m:
Ocorre a interrup√ß√£o de page fault.
O SO escolhe um frame v√≠tima na RAM.
Se a p√°gina no frame v√≠tima foi modificada (dirty bit √© 1), ela √© salva no disco.
A p√°gina necess√°ria √© carregada do disco para o frame v√≠tima.
A tabela de p√°ginas √© atualizada e a execu√ß√£o do programa √© retomada.
Problemas da Mem√≥ria Virtual
Thrashing (Pulsa√ß√£o): Ocorre quando h√° excesso de page faults, fazendo com que o sistema passe mais tempo trocando p√°ginas com o disco do que executando tarefas √∫teis. Isso geralmente acontece quando n√£o h√° frames de mem√≥ria suficientes para o conjunto de trabalho (working set) dos processos ativos.
Algoritmos de Substitui√ß√£o de P√°ginas
Quando um page fault ocorre e todos os frames est√£o ocupados, um algoritmo deve escolher qual p√°gina "v√≠tima" remover:
FIFO (First-In, First-Out): Remove a p√°gina que est√° na mem√≥ria h√° mais tempo. Simples, mas ineficiente se essa p√°gina antiga for frequentemente usada.
√ìtimo (OPT): Remove a p√°gina que ser√° usada mais distante no futuro. √â o ideal te√≥rico, mas imposs√≠vel de implementar na pr√°tica, pois exige prever o futuro.
LRU (Least Recently Used): Remove a p√°gina que n√£o foi usada h√° mais tempo. √â uma boa aproxima√ß√£o pr√°tica do algoritmo √ìtimo, mas tem um custo de implementa√ß√£o maior.
Segunda Chance (Clock): Uma varia√ß√£o do FIFO que d√° uma "segunda chance" para p√°ginas que tiveram seu bit de refer√™ncia marcado recentemente, oferecendo um bom equil√≠brio entre efici√™ncia e baixo overhead.
üî• GER√äNCIA DE DISPOSITIVOS (E/S)
A ger√™ncia de E/S (Entrada/Sa√≠da) abstrai o hardware subjacente para que os programas possam interagir com dispositivos de maneira uniforme.
Arquitetura em Camadas
A comunica√ß√£o flui da aplica√ß√£o para o hardware atrav√©s de v√°rias camadas:
Aplica√ß√£o: Faz chamadas de bibliotecas de alto n√≠vel (ex: fread()).
System Call Interface: O ponto de entrada para o kernel do SO.
Subsistema de E/S do SO: Lida com tarefas gen√©ricas como buffering e agendamento de requisi√ß√µes.
Device Driver (Driver de Dispositivo): Software espec√≠fico que traduz comandos gen√©ricos do SO em comandos de hardware espec√≠ficos para aquele dispositivo (ex: um modelo espec√≠fico de impressora ou disco).
Controlador de Dispositivo: O chip de hardware que executa fisicamente a opera√ß√£o.
Modos de Transfer√™ncia de Dados
Polling (Busy Waiting): A CPU verifica repetidamente o status do dispositivo para ver se ele est√° pronto. Extremamente ineficiente, pois desperdi√ßa ciclos de CPU.
Interrup√ß√µes: O m√©todo padr√£o. O dispositivo sinaliza a CPU atrav√©s de uma interrup√ß√£o quando uma opera√ß√£o √© conclu√≠da ou requer aten√ß√£o.
DMA (Direct Memory Access): Um controlador de DMA gerencia a transfer√™ncia de grandes blocos de dados diretamente entre a mem√≥ria RAM e o dispositivo de E/S, sem envolver a CPU no processo de transfer√™ncia. A CPU √© notificada apenas no in√≠cio e no fim da opera√ß√£o via interrup√ß√£o.
