# üß† **Guia de Estudo Avan√ßado para Sistemas Operacionais**

Baseado nos materiais fornecidos, este guia cobre profundamente os quatro m√≥dulos principais com conceitos t√©cnicos, compara√ß√µes e cen√°rios pr√°ticos.

---

## üî• **PARTE 1: GER√äNCIA DO PROCESSADOR - ESCALONAMENTO**

### üìå **Conceitos Fundamentais**
O **escalonamento de processos** √© o mecanismo pelo qual o SO decide qual processo em estado de **pronto** deve utilizar a CPU. Em sistemas multiprogram√°veis, v√°rios processos competem pela CPU, exigindo pol√≠ticas de escalonamento que otimizem m√©tricas como **throughput**, **tempo de resposta** e **utiliza√ß√£o da CPU**.

### üß© **Arquitetura do Escalonador**
- **Scheduler (Escalonador)**: algoritmo que seleciona o pr√≥ximo processo a ser executado.
- **Dispatcher (Despachante)**: m√≥dulo que realiza a **troca de contexto**, atualizando registradores, PC, e estados do processo.
- **Lat√™ncia de Despacho**: overhead inevit√°vel durante a troca de contexto.

### üìä **M√©tricas de Desempenho**
| M√©trica | F√≥rmula (conceitual) | Objetivo |
|---------|----------------------|----------|
| Throughput | N¬∫ processos conclu√≠dos / tempo | Maximizar |
| Tempo de Turnaround | T√©rmino - Submiss√£o | Minimizar |
| Tempo de Espera | Turnaround - Tempo de CPU | Minimizar |
| Tempo de Resposta | Primeira resposta - Requisi√ß√£o | Minimizar |
| Utiliza√ß√£o da CPU | (Tempo ocupado / Tempo total) √ó 100% | Maximizar |

### ‚öôÔ∏è **Algoritmos de Escalonamento Detalhados**

#### **1. FIFO (First-In, First-Out)**
- **N√£o preemptivo**.
- Processos s√£o executados na ordem de chegada.
- **Problema**: Efeito **convoy** ‚Äì processos longos atrasam processos curtos.
- **Exemplo**: 
  - P1 (24 ms), P2 (3 ms), P3 (3 ms)
  - Tempo m√©dio de espera: (0 + 24 + 27)/3 = 17 ms (alto).

#### **2. SJF (Shortest Job First)**
- Pode ser **n√£o preemptivo** (SJF puro) ou **preemptivo** (SRTF ‚Äì Shortest Remaining Time First).
- **Vantagem**: Menor tempo m√©dio de espera.
- **Desvantagem**: Exige conhecimento pr√©vio do tempo de execu√ß√£o; pode causar **starvation**.
- **Exemplo SRTF**:
  - P1 (8 ms) chega em t=0, P2 (4 ms) chega em t=1.
  - P1 executa 1 ms ‚Üí preemptado por P2 (menor tempo restante).

#### **3. Round Robin (RR)**
- **Preemptivo por quantum de tempo**.
- Cada processo recebe um **quantum** (ex: 10 ms).
- Se n√£o terminar, volta para o final da fila.
- **Trade-off**:
  - Quantum grande ‚Üí aproxima-se do FIFO.
  - Quantum pequeno ‚Üí aumenta trocas de contexto (overhead).
- **Justo**, mas pode prejudicar processos **CPU-bound** em rela√ß√£o a **I/O-bound**.

#### **4. Escalonamento por Prioridades**
- Cada processo tem uma prioridade (est√°tica ou din√¢mica).
- Pode ser **preemptivo** ou **n√£o preemptivo**.
- **Starvation**: processos de baixa prioridade podem nunca executar.
- **Solu√ß√£o**: **Aging** ‚Äì aumenta prioridade com o tempo de espera.

#### **5. M√∫ltiplas Filas (Multilevel Queue)**
- V√°rias filas com diferentes prioridades e pol√≠ticas.
- Exemplo: 
  - Fila de alta prioridade: RR (processos interativos).
  - Fila de baixa prioridade: FIFO (processos em batch).
- **Sem realimenta√ß√£o**: processo n√£o muda de fila.
- **Com realimenta√ß√£o**: processos podem migrar entre filas conforme seu comportamento.

### üß† **An√°lise Comparativa**
| Algoritmo | Preemptivo? | Justi√ßa | Overhead | Starvation | Throughput |
|-----------|-------------|---------|----------|------------|------------|
| FIFO      | N√£o         | Baixa   | Baixo    | N√£o        | M√©dio      |
| SJF       | Opcional    | Alta*   | M√©dio    | Sim        | Alto       |
| RR        | Sim         | Alta    | Alto     | N√£o        | M√©dio      |
| Prioridades| Sim/N√£o    | Vari√°vel| M√©dio    | Sim        | Alto       |

*Justo em termos de tempo de execu√ß√£o, mas n√£o em termos de ordem de chegada.

---

## üî• **PARTE 2: GER√äNCIA DE MEM√ìRIA**

### üß© **Evolu√ß√£o Hist√≥rica**
1. **Monoprograma√ß√£o**: SO + 1 processo.
2. **Multiprograma√ß√£o com parti√ß√µes fixas**: fragmenta√ß√£o interna.
3. **Parti√ß√µes din√¢micas**: fragmenta√ß√£o externa.
4. **Mem√≥ria virtual**: ilus√£o de mem√≥ria infinita.

### üìå **Problemas de Fragmenta√ß√£o**
| Tipo | Causa | Solu√ß√µes Poss√≠veis |
|------|-------|-------------------|
| **Interna** | Espa√ßo desperdi√ßado dentro de uma parti√ß√£o fixa. | Parti√ß√µes din√¢micas, pagina√ß√£o. |
| **Externa** | Espa√ßos livres n√£o cont√≠guos entre processos. | Compacta√ß√£o, segmenta√ß√£o, pagina√ß√£o. |

### ‚öôÔ∏è **Estrat√©gias de Aloca√ß√£o de Mem√≥ria**

#### **First-Fit**
- Aloca na **primeira** parti√ß√£o livre que couber.
- **Vantagem**: R√°pido.
- **Desvantagem**: Pode deixar fragmentos pequenos no in√≠cio.

#### **Best-Fit**
- Aloca na parti√ß√£o que **mais se aproxima** do tamanho necess√°rio.
- **Vantagem**: Minimiza desperd√≠cio na parti√ß√£o.
- **Desvantagem**: Cria muitos fragmentos min√∫sculos in√∫teis.

#### **Worst-Fit**
- Aloca na **maior** parti√ß√£o livre.
- **Vantagem**: Deixa espa√ßo para outros processos.
- **Desvantagem**: Pode desperdi√ßar mem√≥ria em parti√ß√µes grandes.

### üîÑ **Swapping**
- Processos s√£o movidos entre **mem√≥ria principal** e **√°rea de swap** no disco.
- **Swap out**: processo √© removido da RAM.
- **Swap in**: processo √© carregado de volta.
- **Problema**: Lat√™ncia de disco alta ‚Üí **degrada√ß√£o de desempenho** se excessivo.
- **Uso t√≠pico**: Para processos em espera ou de baixa prioridade.

---

## üî• **PARTE 3: MEM√ìRIA VIRTUAL**

### üß© **Conceitos-Chave**
- **Espa√ßo de endere√ßamento virtual**: conjunto de endere√ßos que um processo pode acessar.
- **Espa√ßo de endere√ßamento f√≠sico**: endere√ßos reais da RAM.
- **MMU (Memory Management Unit)**: hardware que traduz endere√ßos virtuais em f√≠sicos.

### üìå **Pagina√ß√£o**
- Mem√≥ria dividida em **p√°ginas** (tamanho fixo, ex: 4 KB).
- Tabela de p√°ginas mant√©m mapeamento **p√°gina virtual ‚Üí frame f√≠sico**.
- **Bit de validade**: 1 = p√°gina na RAM, 0 = p√°gina no disco.
- **Bit de modifica√ß√£o (dirty bit)**: 1 = p√°gina foi alterada, precisa ser salva.

#### **Ciclo de Page Fault**
1. Refer√™ncia a p√°gina inv√°lida (bit=0).
2. Interrup√ß√£o de **page fault**.
3. SO escolhe um frame v√≠tima.
4. Se frame foi modificado, escreve no disco.
5. Carrega p√°gina necess√°ria do disco para RAM.
6. Atualiza tabela de p√°ginas (bit=1).
7. Retoma execu√ß√£o da instru√ß√£o.

### üìå **Segmenta√ß√£o**
- Mem√≥ria dividida em **segmentos** com significado l√≥gico (c√≥digo, dados, pilha).
- Cada segmento tem tamanho vari√°vel.
- **Tabela de segmentos**: armazena **base + limite**.
- **Vantagem**: prote√ß√£o e compartilhamento mais naturais.
- **Desvantagem**: fragmenta√ß√£o externa.

### ‚ö†Ô∏è **Problemas da Mem√≥ria Virtual**
- **Thrashing**: excesso de page faults ‚Üí sistema fica lento.
- **Causa**: poucos frames por processo ‚Üí working set n√£o cabe na RAM.
- **Solu√ß√£o**: aumentar RAM, ajustar algoritmo de substitui√ß√£o, usar working set.

### üîÑ **Algoritmos de Substitui√ß√£o de P√°ginas**
| Algoritmo | Ideia Principal | Vantagens | Desvantagens |
|-----------|----------------|-----------|--------------|
| **FIFO** | Remove a p√°gina mais antiga. | Simples. | Pode remover p√°ginas frequentemente usadas. |
| **√ìtimo (OPT)** | Remove a p√°gina que ser√° usada mais no futuro. | Teoricamente ideal. | Imposs√≠vel implementar (requer conhecimento futuro). |
| **LRU (Least Recently Used)** | Remove a p√°gina n√£o usada h√° mais tempo. | Boa performance na pr√°tica. | Overhead de implementa√ß√£o. |
| **Segunda Chance (Clock)** | FIFO com bit de refer√™ncia; p√°ginas referenciadas ganham segunda chance. | Balanceado entre overhead e efici√™ncia. | Pior que LRU. |

---

## üî• **PARTE 4: GER√äNCIA DE DISPOSITIVOS (E/S)**

### üß© **Arquitetura em Camadas**
1. **Aplica√ß√£o**: faz chamadas de biblioteca (ex: `fread()`).
2. **System Call**: interface com o kernel (ex: `read()`).
3. **Subsistema de E/S do SO**: trata buffering, caching, agendamento.
4. **Device Driver**: converte comandos gen√©ricos em comandos espec√≠ficos do hardware.
5. **Controlador de Dispositivo**: hardware que executa as opera√ß√µes.

### üìå **Buffering e Caching**
- **Buffer**: mem√≥ria tempor√°ria para compensar diferen√ßas de velocidade entre CPU e dispositivos.
- **Caching**: c√≥pia de dados frequentemente acessados em mem√≥ria r√°pida.
- **Spooling**: fila de trabalhos para dispositivos lentos (ex: impressora).

### ‚öôÔ∏è **Tipos de Dispositivos**
| Tipo | Exemplos | Caracter√≠sticas |
|------|----------|-----------------|
| **Bloco** | Discos, SSDs | Acesso por blocos; endere√ß√°vel. |
| **Caractere** | Teclado, mouse | Fluxo cont√≠nuo de bytes. |
| **Rede** | Placas de rede | Comunica√ß√£o serial/paralela. |

### üîÑ **Modos de Transfer√™ncia**
1. **Polling (Busy-Waiting)**: CPU verifica continuamente se dispositivo est√° pronto (ineficiente).
2. **Interrup√ß√µes**: dispositivo sinaliza quando pronto; CPU √© interrompida.
3. **DMA (Direct Memory Access)**: controlador transfere dados diretamente para RAM sem CPU.
   - CPU s√≥ √© envolvida no in√≠cio e fim da transfer√™ncia.
   - **Vantagem**: libera CPU para outras tarefas.

### üõ°Ô∏è **Tratamento de Erros**
- **Recupera√ß√£o a n√≠vel de driver**: tentar novamente, recalibrar.
- **Reporte a n√≠vel de aplica√ß√£o**: ‚Äúdispositivo n√£o dispon√≠vel‚Äù.
- **Falhas fatais**: kernel panic, BSOD (em casos extremos).

---

## ‚úÖ **CHECKLIST PARA A PROVA**

### ‚ùì Perguntas para autoavalia√ß√£o:
- [ ] Sei explicar a diferen√ßa entre SJF preemptivo e n√£o preemptivo?
- [ ] Consigo calcular tempo m√©dio de espera para FIFO, SJF e RR?
- [ ] Sei diferenciar fragmenta√ß√£o interna e externa?
- [ ] Entendo o ciclo completo de um page fault?
- [ ] Consigo explicar como o DMA melhora o desempenho de E/S?
- [ ] Sei listar 3 algoritmos de substitui√ß√£o de p√°ginas e suas caracter√≠sticas?
- [ ] Entendo a hierarquia do subsistema de E/S?
- [ ] Consigo explicar o problema de starvation e como o aging resolve?

### üìà **F√≥rmulas Importantes** (conceituais):
- **Throughput** = processos conclu√≠dos / tempo total
- **Utiliza√ß√£o da CPU** = (tempo √∫til da CPU / tempo total) √ó 100%
- **Tempo de espera m√©dio** = Œ£ (tempo de espera de cada processo) / n¬∫ processos
- **Taxa de page faults** = n¬∫ page faults / tempo

---

## üéØ **DICAS FINAIS**
- **Desenhe diagramas**: filas de escalonamento, tabelas de p√°ginas, fluxo de E/S.
- **Pense em casos extremos**: o que acontece se todos os processos forem CPU-bound? E se forem I/O-bound?
- **Relacione os m√≥dulos**: como a mem√≥ria virtual afeta o escalonamento? Como o swapping interage com a ger√™ncia de mem√≥ria?
- **Revise os slides originais**: os exemplos visuais s√£o essenciais.

Boa prova! üöÄ

Quer que eu gere quest√µes pr√°ticas ou simula√ß√µes com base nesses t√≥picos?
