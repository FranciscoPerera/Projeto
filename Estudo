 üî• GER√äNCIA DO PROCESSADO - ESCALONAMENTO

üìå Conceitos Fundamentais
O escalonamento de processos √© o mecanismo pelo qual o SO decide qual processo em estado de pronto deve utilizar a CPU. Em sistemas multiprogram√°veis, v√°rios processos competem pela CPU, exigindo pol√≠ticas de escalonamento que otimizem m√©tricas como throughput, tempo de resposta e utiliza√ß√£o da CPU.

üß© Arquitetura do Escalonador
    ‚Ä¢ Scheduler (Escalonador): algoritmo que seleciona o pr√≥ximo processo a ser executado.
    ‚Ä¢ Dispatcher (Despachante): m√≥dulo que realiza a troca de contexto, atualizando registradores, PC, e estados do processo.
    ‚Ä¢ Lat√™ncia de Despacho: overhead inevit√°vel durante a troca de contexto.

üìä M√©tricas de Desempenho
M√©trica
F√≥rmula (conceitual)
Objetivo
Throughput
N¬∫ processos conclu√≠dos / tempo
Maximizar
Tempo de Turnaround
T√©rmino  Submiss√£o
Minimizar
Tempo de Espera
Turnaround  Tempo de CPU
Minimizar
Tempo de Resposta
Primeira resposta  Requisi√ß√£o
Minimizar
Utiliza√ß√£o da CPU
(Tempo ocupado / Tempo total) √ó 100%
Maximizar

‚öôÔ∏è Algoritmos de Escalonamento Detalhados

1. FIFO (FirstIn, FirstOut)
    ‚Ä¢ N√£o preemptivo.
    ‚Ä¢ Processos s√£o executados na ordem de chegada.
    ‚Ä¢ Problema: Efeito convoy ‚Äì processos longos atrasam processos curtos.
    ‚Ä¢ Exemplo: 
        ‚ó¶ P1 (24 ms), P2 (3 ms), P3 (3 ms)
        ‚ó¶ Tempo m√©dio de espera: (0 + 24 + 27)/3 = 17 ms (alto).

2. SJF (Shortest Job First)
    ‚Ä¢ Pode ser n√£o preemptivo (SJF puro) ou preemptivo (SRTF ‚Äì Shortest Remaining Time First).
    ‚Ä¢ Vantagem: Menor tempo m√©dio de espera.
    ‚Ä¢ Desvantagem: Exige conhecimento pr√©vio do tempo de execu√ß√£o; pode causar starvation.
    ‚Ä¢ Exemplo SRTF:
        ‚ó¶ P1 (8 ms) chega em t=0, P2 (4 ms) chega em t=1.
        ‚ó¶ P1 executa 1 ms ‚Üí preemptado por P2 (menor tempo restante).

3. Round Robin (RR)
    ‚Ä¢ Preemptivo por quantum de tempo.
    ‚Ä¢ Cada processo recebe um quantum (ex: 10 ms).
    ‚Ä¢ Se n√£o terminar, volta para o final da fila.
    ‚Ä¢ Tradeoff:
        ‚ó¶ Quantum grande ‚Üí aproximase do FIFO.
        ‚ó¶ Quantum pequeno ‚Üí aumenta trocas de contexto (overhead).

 4. Escalonamento por Prioridades
    ‚Ä¢ Cada processo tem uma prioridade (est√°tica ou din√¢mica).
    ‚Ä¢ Pode ser preemptivo ou n√£o preemptivo.
        ‚ó¶ Starvation: processos de baixa prioridade podem nunca executar.
        ‚ó¶ Solu√ß√£o: Aging ‚Äì aumenta prioridade com o tempo de espera.

5. M√∫ltiplas Filas (Multilevel Queue)
    ‚Ä¢ V√°rias filas com diferentes prioridades e pol√≠ticas.
    ‚Ä¢ Exemplo: 
        ‚ó¶ Fila de alta prioridade: RR (processos interativos).
        ‚ó¶ Fila de baixa prioridade: FIFO (processos em batch).
        ‚ó¶ Sem realimenta√ß√£o: processo n√£o muda de fila.
        ‚ó¶ Com realimenta√ß√£o: processos podem migrar entre filas conforme seu comportamento.

üß† An√°lise Comparativa
Algoritmo
Preemptivo
Justi√ßa
Overhead
Starvation
Throughput
FIFO
N√£o
Baixa
Baixo
N√£o
M√©dio
SJF
Opcional
Alta
M√©dio
Sim
Alto
RR
Sim
Alta
Alta
N√£o
M√©dio
Prioridades
Sim/N√£o 
Vari√°vel
M√©dio
Sim
Alto

üî• GER√äNCIA DE MEM√ìRIA

üß© Evolu√ß√£o Hist√≥rica
1. Monoprograma√ß√£o: SO + 1 processo.
2. Multiprograma√ß√£o com parti√ß√µes fixas: fragmenta√ß√£o interna.
3. Parti√ß√µes din√¢micas: fragmenta√ß√£o externa.
4. Mem√≥ria virtual: ilus√£o de mem√≥ria infinita.

üìå Problemas de Fragmenta√ß√£o
Tipo
Causa
Solu√ß√µes Poss√≠veis
Interna
Espa√ßo desperdi√ßado dentro de uma parti√ß√£o fixa.
Parti√ß√µes din√¢micas, pagina√ß√£o.
Externa
Espa√ßos livres n√£o cont√≠guos entre processos.
Compacta√ß√£o, segmenta√ß√£o, pagina√ß√£o.

‚öôÔ∏è Estrat√©gias de Aloca√ß√£o de Mem√≥ria
FirstFit
 Aloca na primeira parti√ß√£o livre que couber.
    ‚Ä¢ Vantagem: R√°pido.
    ‚Ä¢ Desvantagem: Pode deixar fragmentos pequenos no in√≠cio.



BestFit
 Aloca na parti√ß√£o que mais se aproxima do tamanho necess√°rio.
    ‚Ä¢ Vantagem: Minimiza desperd√≠cio na parti√ß√£o.
    ‚Ä¢ Desvantagem: Cria muitos fragmentos min√∫sculos in√∫teis.

WorstFit
 Aloca na maior parti√ß√£o livre.
    ‚Ä¢ Vantagem: Deixa espa√ßo para outros processos.
    ‚Ä¢ Desvantagem: Pode desperdi√ßar mem√≥ria em parti√ß√µes grandes.

 üîÑ Swapping
 Processos s√£o movidos entre mem√≥ria principal e √°rea de swap no disco.
    ‚Ä¢ Swap out: processo √© removido da RAM.
    ‚Ä¢ Swap in: processo √© carregado de volta.
    ‚Ä¢ Problema: Lat√™ncia de disco alta ‚Üí degrada√ß√£o de desempenho se excessivo.
    ‚Ä¢ Uso t√≠pico: Para processos em espera ou de baixa prioridade.



üî•MEM√ìRIA VIRTUAL

 üß© ConceitosChave
    ‚Ä¢ Espa√ßo de endere√ßamento virtual: conjunto de endere√ßos que um processo pode acessar.
    ‚Ä¢ Espa√ßo de endere√ßamento f√≠sico: endere√ßos reais da RAM.
    ‚Ä¢ MMU (Memory Management Unit): hardware que traduz endere√ßos virtuais em f√≠sicos.

 üìå Pagina√ß√£o
    ‚Ä¢ Mem√≥ria dividida em p√°ginas (tamanho fixo, ex: 4 KB).
    ‚Ä¢ Tabela de p√°ginas mant√©m mapeamento p√°gina virtual ‚Üí frame f√≠sico.
    ‚Ä¢ Bit de validade: 1 = p√°gina na RAM, 0 = p√°gina no disco.
    ‚Ä¢ Bit de modifica√ß√£o (dirty bit): 1 = p√°gina foi alterada, precisa ser salva.

Ciclo de Page Fault
      1. Refer√™ncia a p√°gina inv√°lida (bit=0).
      2. Interrup√ß√£o de page fault.
      3. SO escolhe um frame v√≠tima.
      4. Se frame foi modificado, escreve no disco.
      5. Carrega p√°gina necess√°ria do disco para RAM.
      6. Atualiza tabela de p√°ginas (bit=1).
      7. Retoma execu√ß√£o da instru√ß√£o.

 üìå Segmenta√ß√£o
    ‚Ä¢ Mem√≥ria dividida em segmentos com significado l√≥gico (c√≥digo, dados, pilha).
    ‚Ä¢ Cada segmento tem tamanho vari√°vel.
    ‚Ä¢ Tabela de segmentos: armazena base + limite.
    ‚Ä¢ Vantagem: prote√ß√£o e compartilhamento mais naturais.
    ‚Ä¢ Desvantagem: fragmenta√ß√£o externa.

 ‚ö†Ô∏è Problemas da Mem√≥ria Virtual
    ‚Ä¢ Thrashing: excesso de page faults ‚Üí sistema fica lento.
    ‚Ä¢ Causa: poucos frames por processo ‚Üí working set n√£o cabe na RAM.
    ‚Ä¢ Solu√ß√£o: aumentar RAM, ajustar algoritmo de substitui√ß√£o, usar working set.

 üîÑ Algoritmos de Substitui√ß√£o de P√°ginas
Algoritmo
 Ideia Principal 
Vantagens
Desvantagens
FIFO
Remove a p√°gina mais antiga
Simples
Pode remover p√°ginas frequentemente usadas.
 √ìtimo (OPT)
Remove a p√°gina que ser√° usada mais no futuro.
Teoricamente ideal
Imposs√≠vel implementar (requer conhecimento futuro).
 LRU (Least Recently Used)
Remove a p√°gina n√£o usada h√° mais tempo.
Boa performance na pr√°tica.
Overhead de implementa√ß√£o.
Segunda Chance (Clock)
FIFO com bit de refer√™ncia; p√°ginas referenciadas ganham segunda chance
Balanceado entre overhead e efici√™ncia
Pior que LRU.


üî•GER√äNCIA DE DISPOSITIVOS (E/S)

 üß© Arquitetura em Camadas
1. Aplica√ß√£o: faz chamadas de biblioteca (ex: `fread()`).
2. System Call: interface com o kernel (ex: `read()`).
3. Subsistema de E/S do SO: trata buffering, caching, agendamento.
4. Device Driver: converte comandos gen√©ricos em comandos espec√≠ficos do hardware.
5. Controlador de Dispositivo: hardware que executa as opera√ß√µes.

 üìå Buffering e Caching
    ‚Ä¢ Buffer: mem√≥ria tempor√°ria para compensar diferen√ßas de velocidade entre CPU e dispositivos.
    ‚Ä¢ Caching: c√≥pia de dados frequentemente acessados em mem√≥ria r√°pida.
    ‚Ä¢ Spooling: fila de trabalhos para dispositivos lentos (ex: impressora).

 ‚öôÔ∏è Tipos de Dispositivos
Tipo
Exemplos
Caracter√≠sticas
Bloco
Discos, SSDs
Acesso por blocos; endere√ß√°vel
Caractere
Teclado, mouse
 Fluxo cont√≠nuo de bytes.
Rede
 Placas de rede
Comunica√ß√£o serial/paralela.

 üîÑ Modos de Transfer√™ncia
1. Polling (BusyWaiting): CPU verifica continuamente se dispositivo est√° pronto (ineficiente).
2. Interrup√ß√µes: dispositivo sinaliza quando pronto; CPU √© interrompida.
3. DMA (Direct Memory Access): controlador transfere dados diretamente para RAM sem CPU.
    ‚Ä¢ CPU s√≥ √© envolvida no in√≠cio e fim da transfer√™ncia.
    ‚Ä¢ Vantagem: libera CPU para outras tarefas.

 üõ°Ô∏è Tratamento de Erros
    ‚Ä¢ Recupera√ß√£o a n√≠vel de driver: tentar novamente, recalibrar.
    ‚Ä¢ Reporte a n√≠vel de aplica√ß√£o: ‚Äúdispositivo n√£o dispon√≠vel‚Äù.
    ‚Ä¢ Falhas fatais: kernel panic, BSOD (em casos extremos).
